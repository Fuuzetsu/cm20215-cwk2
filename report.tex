\documentclass{report}
\begin{document}
\title{CM20215} \author{Mateusz Kowalczyk (mk440)} \maketitle
\section*{Design}

The first part of the project was to familiarise myself with the
requirements. Inspecting the scenario and the technical specification,
there are only a few core tasks that are required:

\begin{itemize}
\item The program is to be written in Java
\item The program is to work with a list of university employees
\item Each class of an employee can have a different base wage
\item Some classes of employees need extra information to calculate
  the monthly wage.
\end{itemize}

Once these requirements were established, there is a fairly obvious
solution here: creating a generic employee class that we can
manipulate and subclassing it to allow specific classes to provide
different behaviour is a reasonable way to go.

While the technical specifcation mentions that records don't have to
be stored to disk, I decided that it'll be worthwhile to have such a
list of employees for testing purposes. I quickly came up with
primitive, flat record storing mechanism. The only worthwhile thing to
mention is that no specific employee class information is stored
except for the class name: that is, the records themselves don't store
anything like performance pay or number of extra hours worked. The
simple parser implementation is able to recover from any badly
specified records, skipping them if necessary. Please see the
``records.txt'' file for the sample data. This file is loaded by
default if no other file is provided.

Initially my design involved quite a few custom exception types and I
have even gone with that approach in the prototype stage of the
project. In the end, I decided against this: even with checked
exceptions, following the control is very difficult, with exceptions
being able to propagate up many scopes and in the end all my
exceptions were just fancy wrappers for Strings storing the
warnings/messages. Further, code with checked exceptions does not
compose together well at all.  To make the program easier to follow, I
removed all custom exception types and simply used a sum type to carry
and denote any possible failures. I'm using parts of the ``functional
java'' library for this purpose.

The generic employee class is a very simple idea: all employees share
common traits (name, address) but different classes calculate wages
differently. For example, we don't need to specify any extra
information for researchers but we need two extra pieces of
information for lecturers. To implement this, the employee class
requires that an abstract method to calculate the wage is implemented.
The type of this method is again a sum type which either returns the
monthly wage or returns function which when ran asks the user for more
information, does the calculation and returns the monthly wage. Each
subclass of employee is now able to implement this method and ask for
any information it could ever require.

This makes adding new employee classes easy: simply subclass the main
employee class and implement the wage calculation method, requesting
any extra information if required. In this program one would also be
required to implement a very simple record parsing method if we were
to store this new class but it is simply a technicality.

\section*{Implementation}
The implementation was done according to the UML class diagram. I
implement provide a ``uml.jpeg''  image of this diagram as well as a
``uml.plantuml'' file which I used to generate it (before converting
to .jpeg).
\begin{itemize}
  \item{Printing out records on screen}
  \item{Calculating the wage of any of the records}
  \item{Adding a record}
  \item{Removing a record}
\end{itemize}

There is no option to save the database file. Different database files
can be loaded however.

\subsection*{Running the program}
I provide an ant project file as well as the library that the program
depends on. Due to the absolutely inane rules that Java uses to
package files into ``.jar''s, the recommended way to get the program
to build and run is to run ``ant run'' from the top level directory of
the project. You'll of course need ``ant'' installed. Unfortunately
this method causes an ugly prefix to all program output.

The project itself uses Java 7 although it should be very easy to make
it run on Java 6 too. If you do not wish to use ``ant'', know that the
main class is UserInterface and that you'll need the ``functional
java'' library which I provide in ``lib/''.

The defaults will load the provided ``records.txt'' file. You can
specify a different file by simply passing its name as an argument.

\subsection*{Testing}
Due to a small set of features, the testing was done manually. Any
quirks to do with invalid user input that I could find were eliminated
and I check user input at prompt.

The only thing that had to be accounted for that come up during
testing was negative inputs for number of hours or bonus pay. The
specification does not say that the inputs alwayas have to be negative
but due to lack of better direction, I simply require that the
appropriate numbers are 0 or more, be it hours or money. The parser
has been changed accordingly to accomodate for the possibility of
seeing negative wagess (it in fact uses the same methods for
validation as the user interface prompts do).

Any invalid input will be reported by the parser and the UI will catch
it and report it to the user.


\section*{Distributed Environment scenario}
If we are attempting to work in a distributed environment but with our
initial scenario, there is no problem doing so: all we need is some
networking code and we're done as all the data is read-only which
eliminates data integrity. For the purpose of this part of the report,
I'll assume that reading and deletion to and from disk is now desired.

Now that the users are actually able to make changes to the database,
an issue of data integrity comes up. There might be many users wanting
to edit the same data.

For a task of this size, I think client-server model is the most
appropriate: the server is the one with the only current version of
the database and is able to moderate any access/modification requests
from the users: if the user requests changes after someone else
already has, the server is able to easily detect this and take
appropriate action such as informing the user about updated database
state.

Of course with such model efficiency is a concern: if we're denying
changes for every user queued after someone else already modified the
database, a lot of people are going to be fighting for access and
trying to get in. Complex methods can be written which observe which
parts of the database changed and what the user is requesting and act
accordingly. Complexity is increased for queries modifying every
record and we can get down to per-column granularity of control. How
well this would scale is anyone's guess. In conclusion, if I were
asked about providing a distributed environment for this scenario but
scaled up thousands of times, I would almost certainly use of the the
many existing libre (and free) solutions which have been heavily
backed by large companies and hordes of volunteers rather than trying
to implement it myself (and badly).

\section*{Impedance mismatch}
Impedance mismatch is an issue where one tries to model a relational
concept (a database) using object-oriented model. This is the case in
my program, where I attempt to model a database and implement it in
Java. First of all, I should mention that the database we were asked
to implement only contains a few types. Many of those times are
primitives in most real-life database scenarios. Thanks to the fact
that we are using primitives, we don't have any issues with having to
represent complex objects as tables. In fact, we only have one table
due to the sheer simplicity of our database. Still, let us briefly
consider the situation where we have modelled the desired database as
complex objects and now need to actually represent them in relational
way. As we know, an object in OOP ideology is simply encapsulated,
private data that can only be accessed through a public interface.
That interface is what ensures that only the data we need is exposed
and only in a way that we want it to be. Any modifications have to go
through the interface. In a relational model, we have to expose all
that private data, essentially rendering the ideology behind
object-orientation useless. All the data becomes public, free to be
changed and queried in any way, without the interface in the way to
make semantic safety checks. Similarly, the idea of inheritance gets
skewed, as everything has to be transformed into virtual tables that
can be queried. In OO models, it's common to have objects be built
from other objects, while in relational systems, we have what
essentially is a large amount of top level data, only linked by
relations (often tuples specifying what data relates to what).

Another thing to consider is the type system. Even though I mentioned
that we only have primitive types in our system (or things that
directly wrap primitive types therefore can be translated in a
straight forward way), the relational system also restrains the length
of the data, while in most OO languages we are only limited by the
memory. We can enforce the length of data in our programs but it
requires a lot of trickery and makes modelling a lot more difficult.
There is no simple way to impose the relational type system onto an
object-oriented model.

I mentioned the biggest issues when it comes to modelling a relational
system using object-oriented ideas. There are many minor ones that
make the process difficult. Personally, I believe that we shouldn't
try to enforce the object-oriented model on everything and that we
should simply use the right tools. Unfortunately, this often isn't an
option in businesses.
\end{document}
