\documentclass{report}
\begin{document}
\title{CM20215}
\author{Mateusz Kowalczyk (mk440)}
\maketitle
\section*{Design}

The first part of my design process focused on familiarizing myself with the requirements specified by the customers. Although the requirements are very vague, they ask for list manipulation. The main requirement that is specified is the ability to calculate a wage for the current month of any employees in the database. The specification also states that there is no need to implement a mechanism that allows the user to save the data to the disk. Last requirement is that the program be written in Java.  Considering those requirements, I considered what other features need to be put in place in order to provide the functionality. This led me to inspect the type of data that will be stored. It turns out that certain employees need to request additional information when calculating the wage. This means that we can no longer calculate the wages of all the employees in a batch, but we need to provide the user with an interface that will allow them to pick whichever employee they want to calculate the wage for and then input additional values if prompted.

As the specification states that there doesn't need to be a feature that lets the user save the database, I initially decided to not allow the user to add new records. As we need some records to manipulate, I have decided to implement a file parsing functionality that will read records from disk. At this stage, I had to consider how to propagate the exceptions inside of the system, as we are now dealing with I/O and user input. For the most part, I have decided to use Java's built-in exception system to help the flow control, with some custom created exceptions. Only the record parser would return a pair of a possible employee and a boolean indicating a success or failure of a parsing method. The calling method then can throw a parsing exception as normal. This allows me to make a generic record parser that is able to report failure without interrupting the program flow. Having designed this, I realised that my record parser is generic enough that it can be re-used and we can let the user add new records very easily, using that record parser. The decision to allow the user to delete records followed naturally. The user interface will be fully separated from the list manipulation. In fact, it's designed in the way that allows one to have many `databases' and to connect the same user interface instance to any of those. Although possible, the functionality will not be exposed to the user, even though it could be added in trivially if the requirements change in the future.

At this stage, I only had one major design decision left, and that is the format that would be used for reading records. Looking at the data type that is expected to be listed, I realised that the use of non-alphanumeric characters would not collide with the data. My format was therefore to be a file with one record per line. Empty lines or lines starting with \% would be ignored. The record format would be data fields, separated by a pipe character surrounded by a single space. The parser would look for the job title field and then be able to infer the position of all the other fields on a line from that information. There would be basic checks in place, to make sure that no data that would normally be rejected by the type system could be loaded this way. If a parsing of a line failed, the parsing method would signal failure with a false value in a pair. This can than by caught by the calling method and handled in any way deemed appropriate, such as throwing a parsing exception at that point. The very same format will be used when letting the user to add new records. I'd like to mention that the format could be more robust, such as by using named fields. This is taken into consideration and may be put in during the development stage. The format chosen can change at any time before the final release, without changing the implementation of any class but the record parser, thanks to encapsulation provided by object-orientation. You can find a UML diagram saved as an image distributed with this file.

\section*{Implementation}
The implementation was done according to the UML design. The final set of features that is implemented is
\begin{itemize}
  \item{Printing out records on screen}
  \item{Calculating the wage of any of the records}
  \item{Adding a record}
  \item{Removing a record}
\end{itemize}

There is no option to save the database file. Different database files can be loaded however.

\subsection*{Running the program}
To compile the program, go into the directory with code and run javac *.java\\
To run the program, now type in java UserInterface\\

This will load the provided ``records.txt'' file. You can specify a different file by simply passing its name as an argument.

\subsection*{Testing}
Due to a small set of features, the testing was done manually. The things tested for were valid user input, invalid user input and no user input when expected (including feeding \^D character)

A couple of records were added and removed by hand. The program output (but not crashed) a formatting exception when feeding letters in place of numbers to the UI. This was a matter of simple oversight and was fixed easily and should now function.

A more serious issue was not checking for a null character in places where the user was prompted for input that will then be parsed. All of those occurred in places where it was easy to recover from, and proper error checking is now in place.

Those issues were just programming oversights. An issue of a different kind arose fairly quickly. Administrators get overtime pay depending on the number of hours input by the user, and Lecturers get a part of their performance pay. The issue that arose was that when parsing, negative values were accepted. This is a valid behaviour as far as the programmer is concerned, but might be seen as an error by the user. I have decided to remove the issue with the number of hours by simply checking that the value is more than or equal to 0. This still left the issue of negative performance pay in the database file. This had to be fixed in the record parser. Parsing now fails if that value is less than 0. No other issues arose when testing the program. The main area where issues could occur in the record parsing. The small amount of data and the fact that it's just numerical or text data without any real structure to it, close to no validation is done and therefore can't be tested against. Any invalid input will be reported by the parser and the UI will catch it and report it to the user.


\section*{Distributed Environment scenario}
If I were to extend my program to function in a distributed environment, there are a couple of things I would have to think about. First of all, I am going to assume that we are now letting the user to actually add the data to the database. As the specification doesn't require it, all it would take is to write the networking code and serve the data to the users in their own threads. There are no issues with data integrity as the database doesn't change. I am therefore assuming that adding and removing records is allowed and is an instant and permanent change.

Now that the users are actually able to make changes to the database, an issue of data integrity comes up. There might be many users wanting to edit the same data.

Personally, I would use a client-server model, due to ease of use, and ensuring that there is only one central version of the database that the server needs to consider. This allows the server to act upon the user requests while keeping its own local copy up to date.
Using this model, it becomes fairly easy to manage the database. An example implementation would use a request queue. To provide safety, the clients would also send what the original record looked like, on top of what changes they want to make to it. The server will then be able to compare this record with its current copy and decide whether the record has changed between the user has seen it and edited it. If it has changed, the server simply denies the change and notifies the client about the change and sends an updated record back so the user can take note of the change. All operations that do not require writing to the database can be easily processed and fulfilled at any time.

It should be noted that the above solution is not very efficient, and would fail in real life scenario. An example situation where it would fail is when a user wanted to update the values of every record. Sending the records one by one would be incredibly inefficient. We could implement functions that allow this to be done easily with a command and the update is done by the server automatically. Assuming the succeeds, all other client requests afterwards will fail for all the records. Ideally, they need to be informed by the server about this change and update their local copy accordingly. The mass change can also fail. What if someone change a single record between when the database is read by the client and the command to update is sent by the client? As we are not sending all records in this situation (as that would require sending the whole database), we have no way to tell if the change is what the client desired.

This is just a tip of an ice-berg of data integrity. I can not be possibly expected to provide the solution for this issue. Personally, I'd recommend the client to any free (as in freedom) solutions currently available that strive to achieve just that. There is a great amount of research and heavy investment into this area by many companies and one solution does not fit all. If I know that the database is always going to be small, I would implement the system where the user also has to send a record to make a change. If I knew that the user base is going to be small (but the database large), I would implement the command system with database locking exclusive to the user. In case of the situation where the database is large and has many users (therefore many updates), I'd direct the customer to a company specializing in large-scale database solutions.

\section*{Impedance mismatch}
Impedance mismatch is an issue where one tries to model a relational concept (a database) using object-oriented model. This is the case in my program, where I attempt to model a database and implement it in Java. First of all, I should mention that the database we were asked to implement only contains a few types. Many of those times are primitives in most real-life database scenarios. Thanks to the fact that we are using primitives, we don't have any issues with having to represent complex objects as tables. In fact, we only have one table due to the sheer simplicity of our database. Still, let us briefly consider the situation where we have modelled the desired database as complex objects and now need to actually represent them in relational way. As we know, an object in OOP ideology is simply encapsulated, private data that can only be accessed through a public interface. That interface is what ensures that only the data we need is exposed and only in a way that we want it to be. Any modifications have to go through the interface. In a relational model, we have to expose all that private data, essentially rendering the ideology behind object-orientation useless. All the data becomes public, free to be changed and queried in any way, without the interface in the way to make semantic safety checks. Similarly, the idea of inheritance gets skewed, as everything has to be transformed into virtual tables that can be queried. In OO models, it's common to have objects be built from other objects, while in relational systems, we have what essentially is a large amount of top level data, only linked by relations (often tuples specifying what data relates to what).

Another thing to consider is the type system. Even though I mentioned that we only have primitive types in our system (or things that directly wrap primitive types therefore can be translated in a straight forward way), the relational system also restrains the length of the data, while in most OO languages we are only limited by the memory. We can enforce the length of data in our programs but it requires a lot of trickery and makes modelling a lot more difficult. There is no simple way to impose the relational type system onto an object-oriented model.

I mentioned the biggest issues when it comes to modelling a relational system using object-oriented ideas. There are many minor ones that make the process difficult. Personally, I believe that we shouldn't try to enforce the object-oriented model on everything and that we should simply use the right tools. Unfortunately, this often isn't an option in businesses.
\end{document}
