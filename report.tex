\documentclass{report}
\begin{document}
\title{CM20215} \author{Mateusz Kowalczyk (mk440)} \maketitle
\section*{Design}

The first part of the project was to familiarise myself with the
requirements. Inspecting the scenario and the technical specification,
there are only a few core tasks that are required:

\begin{itemize}
\item The program is to be written in Java
\item The program is to work with a list of university employees
\item Each class of an employee can have a different base wage
\item Some classes of employees need extra information to calculate
  the monthly wage.
\end{itemize}

Once these requirements were established, there is a fairly obvious
solution here: creating a generic employee class that we can
manipulate and subclassing it to allow specific classes to provide
different behaviour is a reasonable way to go.

While the technical specifcation mentions that records don't have to
be stored to disk, I decided that it'll be worthwhile to have such a
list of employees for testing purposes. I quickly came up with
primitive, flat record storing mechanism. The only worthwhile thing to
mention is that no specific employee class information is stored
except for the class name: that is, the records themselves don't store
anything like performance pay or number of extra hours worked. The
simple parser implementation is able to recover from any badly
specified records, skipping them if necessary. Please see the
``records.txt'' file for the sample data. This file is loaded by
default if no other file is provided.

Initially my design involved quite a few custom exception types and I
have even gone with that approach in the prototype stage of the
project. In the end, I decided against this: even with checked
exceptions, following the control is very difficult, with exceptions
being able to propagate up many scopes and in the end all my
exceptions were just fancy wrappers for Strings storing the
warnings/messages. Further, code with checked exceptions does not
compose together well at all.  To make the program easier to follow, I
removed all custom exception types and simply used a sum type to carry
and denote any possible failures. I'm using parts of the ``functional
java'' library for this purpose.

The generic employee class is a very simple idea: all employees share
common traits (name, address) but different classes calculate wages
differently. For example, we don't need to specify any extra
information for researchers but we need two extra pieces of
information for lecturers. To implement this, the employee class
requires that an abstract method to calculate the wage is implemented.
The type of this method is again a sum type which either returns the
monthly wage or returns function which when ran asks the user for more
information, does the calculation and returns the monthly wage. Each
subclass of employee is now able to implement this method and ask for
any information it could ever require.

This makes adding new employee classes easy: simply subclass the main
employee class and implement the wage calculation method, requesting
any extra information if required. In this program one would also be
required to implement a very simple record parsing method if we were
to store this new class but it is simply a technicality.

\section*{Implementation}
The implementation was done according to the UML class diagram. I
implement provide a ``uml.jpeg''  image of this diagram as well as a
``uml.plantuml'' file which I used to generate it (before converting
to .jpeg).
\begin{itemize}
  \item{Printing out records on screen}
  \item{Calculating the wage of any of the records}
  \item{Adding a record}
  \item{Removing a record}
\end{itemize}

There is no option to save the database file. Different database files
can be loaded however.

\subsection*{Running the program}
I provide an ant project file as well as the library that the program
depends on. Due to the absolutely inane rules that Java uses to
package files into ``.jar''s, the recommended way to get the program
to build and run is to run ``ant run'' from the top level directory of
the project. You'll of course need ``ant'' installed. Unfortunately
this method causes an ugly prefix to all program output.

The project itself uses Java 7 although it should be very easy to make
it run on Java 6 too. If you do not wish to use ``ant'', know that the
main class is UserInterface and that you'll need the ``functional
java'' library which I provide in ``lib/''.

The defaults will load the provided ``records.txt'' file. You can
specify a different file by simply passing its name as an argument.

\subsection*{Testing}
Due to a small set of features, the testing was done manually. Any
quirks to do with invalid user input that I could find were eliminated
and I check user input at prompt.

The only thing that had to be accounted for that come up during
testing was negative inputs for number of hours or bonus pay. The
specification does not say that the inputs alwayas have to be negative
but due to lack of better direction, I simply require that the
appropriate numbers are 0 or more, be it hours or money. The parser
has been changed accordingly to accomodate for the possibility of
seeing negative wagess (it in fact uses the same methods for
validation as the user interface prompts do).

Any invalid input will be reported by the parser and the UI will catch
it and report it to the user.


\section*{Distributed Environment scenario}
If I were to extend my program to function in a distributed
environment, there are a couple of things I would have to think about.
First of all, I am going to assume that we are now letting the user to
actually add the data to the database. As the specification doesn't
require it, all it would take is to write the networking code and
serve the data to the users in their own threads. There are no issues
with data integrity as the database doesn't change. I am therefore
assuming that adding and removing records is allowed and is an instant
and permanent change.

Now that the users are actually able to make changes to the database,
an issue of data integrity comes up. There might be many users wanting
to edit the same data.

Personally, I would use a client-server model, due to ease of use, and
ensuring that there is only one central version of the database that
the server needs to consider. This allows the server to act upon the
user requests while keeping its own local copy up to date. Using this
model, it becomes fairly easy to manage the database. An example
implementation would use a request queue. To provide safety, the
clients would also send what the original record looked like, on top
of what changes they want to make to it. The server will then be able
to compare this record with its current copy and decide whether the
record has changed between the user has seen it and edited it. If it
has changed, the server simply denies the change and notifies the
client about the change and sends an updated record back so the user
can take note of the change. All operations that do not require
writing to the database can be easily processed and fulfilled at any
time.

It should be noted that the above solution is not very efficient, and
would fail in real life scenario. An example situation where it would
fail is when a user wanted to update the values of every record.
Sending the records one by one would be incredibly inefficient. We
could implement functions that allow this to be done easily with a
command and the update is done by the server automatically. Assuming
the succeeds, all other client requests afterwards will fail for all
the records. Ideally, they need to be informed by the server about
this change and update their local copy accordingly. The mass change
can also fail. What if someone change a single record between when the
database is read by the client and the command to update is sent by
the client? As we are not sending all records in this situation (as
that would require sending the whole database), we have no way to tell
if the change is what the client desired.

This is just a tip of an ice-berg of data integrity. I can not be
possibly expected to provide the solution for this issue. Personally,
I'd recommend the client to any free (as in freedom) solutions
currently available that strive to achieve just that. There is a great
amount of research and heavy investment into this area by many
companies and one solution does not fit all. If I know that the
database is always going to be small, I would implement the system
where the user also has to send a record to make a change. If I knew
that the user base is going to be small (but the database large), I
would implement the command system with database locking exclusive to
the user. In case of the situation where the database is large and has
many users (therefore many updates), I'd direct the customer to a
company specializing in large-scale database solutions.

\section*{Impedance mismatch}
Impedance mismatch is an issue where one tries to model a relational
concept (a database) using object-oriented model. This is the case in
my program, where I attempt to model a database and implement it in
Java. First of all, I should mention that the database we were asked
to implement only contains a few types. Many of those times are
primitives in most real-life database scenarios. Thanks to the fact
that we are using primitives, we don't have any issues with having to
represent complex objects as tables. In fact, we only have one table
due to the sheer simplicity of our database. Still, let us briefly
consider the situation where we have modelled the desired database as
complex objects and now need to actually represent them in relational
way. As we know, an object in OOP ideology is simply encapsulated,
private data that can only be accessed through a public interface.
That interface is what ensures that only the data we need is exposed
and only in a way that we want it to be. Any modifications have to go
through the interface. In a relational model, we have to expose all
that private data, essentially rendering the ideology behind
object-orientation useless. All the data becomes public, free to be
changed and queried in any way, without the interface in the way to
make semantic safety checks. Similarly, the idea of inheritance gets
skewed, as everything has to be transformed into virtual tables that
can be queried. In OO models, it's common to have objects be built
from other objects, while in relational systems, we have what
essentially is a large amount of top level data, only linked by
relations (often tuples specifying what data relates to what).

Another thing to consider is the type system. Even though I mentioned
that we only have primitive types in our system (or things that
directly wrap primitive types therefore can be translated in a
straight forward way), the relational system also restrains the length
of the data, while in most OO languages we are only limited by the
memory. We can enforce the length of data in our programs but it
requires a lot of trickery and makes modelling a lot more difficult.
There is no simple way to impose the relational type system onto an
object-oriented model.

I mentioned the biggest issues when it comes to modelling a relational
system using object-oriented ideas. There are many minor ones that
make the process difficult. Personally, I believe that we shouldn't
try to enforce the object-oriented model on everything and that we
should simply use the right tools. Unfortunately, this often isn't an
option in businesses.
\end{document}
